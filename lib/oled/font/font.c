/**
 * @file font.c
 * @brief Source file containing the ASCII font table data and character lookup function for text rendering.
 * 
 * This file defines the font data table for ASCII characters, supporting both uppercase and lowercase (unless excluded by macros). The font table can be located either in EEPROM or program memory (PROGMEM), depending on compile-time options. The character table entries represent the bitmap patterns for individual characters, which are selected by the lookup function `font_getchararray()`. This function handles bounds checking and optional conversion of lowercase to uppercase letters when enabled, to optimize memory usage. The table and accessor function are designed for use in embedded systems with constrained storage, such as microcontrollers, where font data is read for graphical text displays.
 *
 * The configuration macros allow customization:
 * - `FONT_STORE_IN_EEPROM`: Store font table in EEPROM instead of PROGMEM.
 * - `FONT_IGNORE_LOWER_CASE`: Do not store or display lowercase letters, saving memory.
 * - `FONT_ASCII_START_CHAR` / `FONT_ASCII_END_CHAR`: Configure supported character range.
 *
 * @author g.raf
 * @date 2025-09-03
 * @version 1.0 Release
 * @copyright
 * Copyright (c) 2025 g.raf
 * Released under the MIT License. (see LICENSE in repository)
 *
 * @note This file is part of a larger project and subject to the license specified in the repository. For updates and the complete revision history, see the GitHub repository.
 *
 * @see https://github.com/0x007e/oled "AVR ATmega GitHub Repository"
 */

#include "font.h"

#ifdef FONT_STORE_IN_EEPROM
	const unsigned char font_ascii_table[][FONT_WIDTH] EEMEM = {
#else
	const unsigned char font_ascii_table[][FONT_WIDTH] PROGMEM = {
#endif
	// 0x20 -> SPACE
	{	0x00, 0x00, 0x00, 0x00, 0x00	},
	// 0x21 -> !
	{	0x00, 0x00, 0xBE, 0x00, 0x00	},
	// 0x22 -> "
	{	0x00, 0x0E, 0x00, 0x0E, 0x00	},
	// 0x23 -> #
	{	0x24, 0x7E, 0x24, 0x7E, 0x24	},
	// 0x24 -> $
	{	0x08, 0x54, 0xFE, 0x54, 0x20	},
	// 0x25 -> %
	{	0x44, 0x20, 0x10, 0x08, 0x44	},
	// 0x26 -> &
	{	0x6C, 0x92, 0xAC, 0x40, 0xA0	},
	// 0x27 -> '
	{	0x00, 0x00, 0x0E, 0x00, 0x00	},
	// 0x28 -> (
	{	0x38, 0x44, 0x82, 0x00, 0x00	},
	// 0x29 -> )
	{	0x00, 0x00, 0x82, 0x44, 0x38	},
	// 0x2A -> *
	{	0x00, 0x0A, 0x04, 0x0A, 0x00	},
	// 0x2B -> +
	{	0x10, 0x10, 0x7C, 0x10, 0x10	},
	// 0x2C -> ,
	{	0x00, 0x00, 0x80, 0x60, 0x00	},
	// 0x2D -> -
	{	0x10, 0x10, 0x10, 0x10, 0x10	},
	// 0x2E -> .
	{	0x00, 0xC0, 0xC0, 0x00, 0x00	},
	// 0x2F -> /
	{	0x40, 0x20, 0x10, 0x08, 0x04	},
	// 0x30 -> 0
	{	0x00, 0x7C, 0x82, 0x7C, 0x00	},
	// 0x31 -> 1
	{	0x00, 0x08, 0x04, 0xFE, 0x00	},
	// 0x32 -> 2
	{	0x00, 0xF2, 0x92, 0x9E, 0x00	},
	// 0x33 -> 3
	{	0x00, 0x92, 0x92, 0xFE, 0x00	},
	// 0x34 -> 4
	{	0x00, 0x1E, 0x10, 0xFE, 0x00	},
	// 0x35 -> 5
	{	0x00, 0x9E, 0x92, 0xF2, 0x00	},
	// 0x36 -> 6
	{	0x00, 0xFE, 0x92, 0xF2, 0x00	},
	// 0x37 -> 7
	{	0x00, 0x02, 0x02, 0xFE, 0x00	},
	// 0x38 -> 8
	{	0x00, 0x6C, 0x92, 0x6C, 0x00	},
	// 0x39 -> 9
	{	0x00, 0x9E, 0x92, 0xFE, 0x00	},
	// 0x3A -> :
	{	0x00, 0x00, 0x28, 0x00, 0x00	},
	// 0x3B -> ;
	{	0x00, 0x80, 0x68, 0x00, 0x00	},
	// 0x3C -> <
	{	0x00, 0x10, 0x28, 0x44, 0x00	},
	// 0x3D -> =
	{	0x00, 0x28, 0x28, 0x28, 0x00	},
	// 0x3E -> >
	{	0x00, 0x44, 0x28, 0x10, 0x00	},
	// 0x3F -> ?
	{	0x00, 0x04, 0xB2, 0x0C, 0x00	},
	// 0x40 -> @
	{	0x7C, 0x82, 0xBA, 0xB2, 0x9C	},
	// 0x41 -> A
	{	0xF8, 0x24, 0x22, 0x24, 0xF8	},
	// 0x42 -> B
	{	0xFE, 0x92, 0x92, 0x92, 0x6C	},
	// 0x43 -> C
	{	0x7C, 0x82, 0x82, 0x82, 0x82	},
	// 0x44 -> D
	{	0xFE, 0x82, 0x82, 0x82, 0x7C	},
	// 0x45 -> E
	{	0xFE, 0x92, 0x92, 0x92, 0x82	},
	// 0x46 -> F
	{	0xFE, 0x12, 0x12, 0x12, 0x02	},
	// 0x47 -> G
	{	0x7C, 0x82, 0x92, 0x92, 0x62	},
	// 0x48 -> H
	{	0xFE, 0x10, 0x10, 0x10, 0xFE	},
	// 0x49 -> I
	{	0x82, 0x82, 0xFE, 0x82, 0x82	},
	// 0x4A -> J
	{	0x40, 0x80, 0x80, 0x80, 0x7E	},
	// 0x4B -> K
	{	0xFE, 0x10, 0x28, 0x44, 0x82	},
	// 0x4C -> L
	{	0xFE, 0x80, 0x80, 0x80, 0x80	},
	// 0x4D -> M
	{	0xFE, 0x04, 0x08, 0x04, 0xFE	},
	// 0x4E -> N
	{	0xFE, 0x08, 0x10, 0x20, 0xFE	},
	// 0x4F -> O
	{	0x7C, 0x82, 0x82, 0x82, 0x7C	},
	// 0x50 -> P
	{	0xFE, 0x12, 0x12, 0x12, 0x0C	},
	// 0x51 -> Q
	{	0x7C, 0x82, 0xA2, 0x42, 0xBC	},
	// 0x52 -> R
	{	0xFE, 0x12, 0x32, 0x52, 0x8C	},
	// 0x53 -> S
	{	0x9E, 0x92, 0x92, 0x92, 0xF2	},
	// 0x54 -> T
	{	0x02, 0x02, 0xFE, 0x02, 0x02	},
	// 0x55 -> U
	{	0x7E, 0x80, 0x80, 0x80, 0x7E	},
	// 0x56 -> V
	{	0x3E, 0x40, 0x80, 0x40, 0x3E	},
	// 0x57 -> W
	{	0x7E, 0x80, 0x7C, 0x80, 0x7E	},
	// 0x58 -> X
	{	0x82, 0x44, 0x38, 0x44, 0x82	},
	// 0x59 -> Y
	{	0x02, 0x04, 0xF8, 0x04, 0x02	},
	// 0x5A -> Z
	{	0xC2, 0xA2, 0x92, 0x8A, 0x86	},
	// 0x5B -> [
	{	0x00, 0xFE, 0x82, 0x82, 0x00	},
	// 0x5C -> \//
	{	0x04, 0x08, 0x10, 0x20, 0x40	},
	// 0x5D -> ]
	{	0x00, 0x82, 0x82, 0xFE, 0x00	},
	// 0x5E -> ^
	{	0x08, 0x04, 0x02, 0x04, 0x08	},
	// 0x5F -> _
	{	0x80, 0x80, 0x80, 0x80, 0x80	},
	// 0x60 -> `
	{	0x00, 0x01, 0x02, 0x04, 0x00	},
#ifndef FONT_IGNORE_LOWER_CASE
	// 0x60 -> a
	{	0x60, 0x90, 0x90, 0xF0, 0x00	},
	// 0x61 -> b
	{	0xFE, 0x90, 0x90, 0x60, 0x00	},
	// 0x62 -> c
	{	0x60, 0x90, 0x90, 0x90, 0x00	},
	// 0x63 -> d
	{	0x60, 0x90, 0x90, 0xFE, 0x00	},
	// 0x64 -> e
	{	0x70, 0xA8, 0xA8, 0x90, 0x00	},
	// 0x65 -> f
	{	0x00, 0x10, 0xFC, 0x12, 0x00	},
	// 0x66 -> g
	{	0x90, 0xA8, 0xA8, 0x70, 0x00	},
	// 0x67 -> h
	{	0xFE, 0x10, 0x10, 0xE0, 0x00	},
	// 0x68 -> i
	{	0x00, 0x80, 0xF4, 0x80, 0x00	},
	// 0x69 -> j
	{	0x00, 0x80, 0x74, 0x00, 0x00	},
	// 0x6A -> k
	{	0xFE, 0x30, 0x48, 0x80, 0x00	},
	// 0x6B -> l
	{	0x00, 0x00, 0x7E, 0x80, 0x00	},
	// 0x6C -> m
	{	0xF0, 0x10, 0xF0, 0x10, 0xE0	},
	// 0x6D -> n
	{	0xF0, 0x10, 0x10, 0xE0, 0x00	},
	// 0x6E -> o
	{	0x60, 0x90, 0x90, 0x60, 0x00	},
	// 0x6F -> p
	{	0xF8, 0x28, 0x28, 0x10, 0x00	},
	// 0x70 -> q
	{	0x10, 0x28, 0x28, 0xF0, 0x00	},
	// 0x71 -> r
	{	0xF0, 0x10, 0x10, 0x20, 0x00	},
	// 0x72 -> s
	{	0x90, 0xA8, 0xA8, 0x40, 0x00	},
	// 0x73 -> t
	{	0x00, 0x08, 0x7C, 0x88, 0x00	},
	// 0x74 -> u
	{	0x70, 0x80, 0x80, 0xF0, 0x00	},
	// 0x75 -> v
	{	0x70, 0x80, 0x80, 0x70, 0x00	},
	// 0x76 -> w
	{	0x70, 0x80, 0x60, 0x80, 0x70	},
	// 0x77 -> x
	{	0x00, 0x90, 0x60, 0x90, 0x00	},
	// 0x78 -> y
	{	0x00, 0x98, 0xA0, 0x78, 0x00	},
	// 0x79 -> z
#endif
	{	0x90, 0xD0, 0xB0, 0x90, 0x00	},
	// 0x7A -> {
	{	0x10, 0x6C, 0x82, 0x82, 0x00	},
	// 0x7B -> |
	{	0x00, 0x00, 0xFE, 0x00, 0x00	},
	// 0x7C -> }
	{	0x00, 0x82, 0x82, 0x6C, 0x10	},
	// 0x7D -> ~
	{	0x20, 0x10, 0x20, 0x10, 0x00	}
};

/**
 * @brief Retrieves the bitmap array for a given ASCII character from the font table.
 * 
 * @param character The ASCII character to retrieve the bitmap for.
 * @return Pointer to a static array for storing the bitmap bytes representing the character.
 * 
 * @details
 * This function maps an input ASCII character to its corresponding bitmap pattern stored  in the font table. If the character is outside the supported ASCII range defined by `FONT_ASCII_START_CHAR` and `FONT_ASCII_END_CHAR`, it defaults is the '?' character. When the macro `FONT_IGNORE_LOWER_CASE` is defined, lowercase letters are converted to uppercase to save memory, and adjustments are made to the character code accordingly.
 * 
 * @note The bitmap data is read from either EEPROM or program memory (PROGMEM) depending on the macro `FONT_STORE_IN_EEPROM`. The data is copied into a static temporary array and a pointer to this array is returned for use in rendering.
 */
unsigned char* font_getchararray(char character)
{
	if(character < FONT_ASCII_START_CHAR || character > FONT_ASCII_END_CHAR)
	{
		character = '?';
	}
	
	#ifdef FONT_IGNORE_LOWER_CASE
		character = toupper(character);
		
		if(character > 'z')
		{
			character = character - ('z' - 'a');
		}
	#endif
	
	static unsigned char temp[sizeof(font_ascii_table[0])/sizeof(font_ascii_table[0][0])];
	
	for (unsigned char i=0; i < sizeof(font_ascii_table[0])/sizeof(font_ascii_table[0][0]); i++)
	{
		#ifdef FONT_STORE_IN_EEPROM
			temp[i] = eeprom_read_byte(&font_ascii_table[(character - FONT_ASCII_START_CHAR)][i]);
		#else
			temp[i] = pgm_read_byte(&font_ascii_table[(character - FONT_ASCII_START_CHAR)][i]);
		#endif
	}
	
	return temp;
}
