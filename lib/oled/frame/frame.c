/**
 * @file frame.c
 * @brief Source file implementing frame management and drawing functions for OLED display.
 * 
 * This file contains the implementation of functions to initialize the frame system, draw text and numbers with various numeric formats, render progress bars, and manage display areas. It supports an optional specific background image stored in program memory, which is drawn and maintained during display updates to ensure visual consistency. The rendering functions integrate with font data and OLED driver modules to output characters and graphical elements. Numeric drawing supports unsigned, signed, and optionally decimal numbers with configurable precision. The code is designed for embedded environments with memory constraints, utilizing PROGMEM for constant data storage and conditional compilation for feature configuration.
 * 
 * @author g.raf
 * @date 2025-09-03
 * @version 1.0 Release
 * @copyright
 * Copyright (c) 2025 g.raf
 * Released under the MIT License. (see LICENSE in repository)
 * 
 * @note This file is part of a larger project and subject to the license specified in the repository. For detailed updates and revision history, see the GitHub repository.
 * 
 * @see https://github.com/0x007e/oled "AVR ATmega GitHub Repository"
 */

#include "frame.h"

#ifdef FRAME_SPECIFIC_BACKGROUND
	const unsigned char frame_background[8][128] PROGMEM = {
		{
			0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 
			0x20, 0x70, 0xD8, 0x8C, 0x06, 0x02, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF
		},
		{
			0x00, 0x00, 0x6F, 0x6F, 0x00, 0x00, 0x00, 0x78, 
			0x70, 0x70, 0x58, 0x0D, 0x07, 0x02, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x07, 0x04, 0x04, 0x04, 0x04, 0x04, 
			0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
			0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x07
		},
		{
			0xE0, 0xF0, 0x30, 0x30, 0x30, 0xF0, 0xE0, 0x00, 
			0x00, 0x00, 0x00, 0xF0, 0xF0, 0x30, 0x30, 0x30, 
			0x20, 0x00, 0xE0, 0xF0, 0x30, 0x30, 0x30, 0xF0, 
			0xF0, 0x00, 0x30, 0x30, 0xFF, 0xFF, 0x31, 0x31, 
			0x00, 0x00, 0x00, 0xE0, 0xF0, 0xB0, 0xB0, 0xB0, 
			0xF0, 0x60, 0x00, 0xF0, 0xF0, 0x30, 0x30, 0x30, 
			0xF0, 0xE0, 0x00, 0xE0, 0xF0, 0x30, 0x30, 0x30, 
			0xF0, 0xE0, 0x00, 0xF6, 0xF6, 0x00, 0xF0, 0xF0, 
			0x30, 0x30, 0x30, 0xF0, 0xE0, 0x00, 0xE0, 0xF0, 
			0xB0, 0xB0, 0xB0, 0xF0, 0x60, 0x00, 0xE0, 0xF0, 
			0xB0, 0xB0, 0xB0, 0xF0, 0x60, 0x00, 0xF0, 0xF0, 
			0x30, 0x30, 0x30, 0x20, 0x00, 0xF6, 0xF6, 0x00, 
			0xF0, 0xF0, 0x30, 0x30, 0x30, 0xF0, 0xE0, 0x00, 
			0xE0, 0xF0, 0x30, 0x30, 0x30, 0xF0, 0xE0, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		},
		{
			0x13, 0x57, 0xD6, 0xD6, 0xD6, 0xFF, 0x7F, 0x10, 
			0x16, 0x16, 0x10, 0x17, 0x17, 0x10, 0x10, 0x10, 
			0x10, 0x10, 0x13, 0x17, 0x16, 0x16, 0x16, 0x17, 
			0x17, 0x10, 0x10, 0x10, 0x1F, 0x1F, 0x10, 0x10, 
			0x10, 0x10, 0x10, 0x13, 0x17, 0x16, 0x16, 0x16, 
			0x12, 0x10, 0x10, 0x17, 0x17, 0x10, 0x10, 0x10, 
			0x17, 0x17, 0x10, 0x13, 0x57, 0xD6, 0xD6, 0xD6, 
			0xFF, 0x7F, 0x10, 0x17, 0x17, 0x10, 0x17, 0x17, 
			0x10, 0x10, 0x10, 0x17, 0x17, 0x10, 0x13, 0x17, 
			0x16, 0x16, 0x16, 0x12, 0x10, 0x10, 0x13, 0x17, 
			0x16, 0x16, 0x16, 0x12, 0x10, 0x10, 0x17, 0x17, 
			0x10, 0x10, 0x10, 0x10, 0x10, 0x17, 0x17, 0x10, 
			0x17, 0x17, 0x10, 0x10, 0x10, 0x17, 0x17, 0x10, 
			0x13, 0x57, 0xD6, 0xD6, 0xD6, 0xFF, 0x7F, 0x10, 
			0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		},
		{
			0xE0, 0x00, 0x00, 0x00, 0xE0, 0x00, 0xC0, 0x20, 
			0x20, 0x20, 0xC0, 0x00, 0xE0, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0xE0, 0x00, 
			0xE0, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		},
		{
			0xE3, 0x24, 0x28, 0x24, 0x23, 0x20, 0x2F, 0x21, 
			0x21, 0x21, 0x2F, 0x20, 0x2F, 0x28, 0x28, 0x28, 
			0x28, 0x20, 0xE7, 0x08, 0x08, 0x08, 0x07, 0x00, 
			0x0F, 0x09, 0x09, 0x09, 0x08, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0xD0, 0x00, 0x10, 0x20, 0xC0, 0x20, 0xC0, 
			0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x80, 0x40, 0x20, 0xF0, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0xC0, 0x20, 0x10, 0x10, 
			0x20, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		},
		{
			0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
			0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
			0x80, 0x80, 0xFF, 0x00, 0x10, 0x09, 0x04, 0x12, 
			0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 
			0x49, 0x49, 0x49, 0x49, 0x0E, 0x00, 0x02, 0x04, 
			0x04, 0x03, 0x00, 0x00, 0x00, 0x07, 0x00, 0x07, 
			0x00, 0x00, 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 
			0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x14, 0x14, 
			0x14, 0x14, 0x14, 0x00, 0x1F, 0x20, 0x40, 0x40, 
			0x20, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		},
		{
			0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
			0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
			0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
			0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
			0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
			0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
			0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
			0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
			0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
			0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
			0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
			0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
			0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
			0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
			0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
			0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF
		}
	};
#endif

/**
 * @brief Initializes the frame system and OLED display.
 * 
 * This function initializes the OLED display by calling the OLED driver initialization function (`oled_init()`) and then clears the display frame to prepare it for new content using `frame_clear()`. It should be called once during system startup before any text or graphics are drawn.
 * 
 * @note This setup ensures the OLED hardware is ready and the display memory is cleared to a known state.
 */
void frame_init(void)
{
	oled_init();
	frame_clear();
}

#ifdef FRAME_SPECIFIC_BACKGROUND
	static void frame_background_segment(unsigned char column_start, unsigned char column_stop, unsigned char page)
	{
		if(page >= FRAME_HEIGHT || column_stop >= FRAME_WIDTH || column_start >= column_stop)
		{
			return;
		}
		
		for (unsigned char x=column_start; x <= column_stop; x++)
		{
			oled_column(pgm_read_byte(&frame_background[page][x]), x, page);
		}
	}
#endif

/**
 * @brief Renders a text string on the OLED display at a specified position.
 * 
 * This function draws the given null-terminated string starting at the coordinates specified by `position`. It calculates affected display pages based on character height  and handles multi-page rendering for characters that span page boundaries. For each character in the string, the corresponding font bitmap is fetched and individual bytes are combined with the optional background pattern (if enabled) to preserve display background beneath the text. Bit-shifting is applied to properly align the character pixels vertically on partial pages. The function outputs the composed columns of pixel data to the OLED display using the lower-level `oled_column` function.
 *
 * @param text Pointer to the null-terminated string to be drawn.
 * @param position The starting position (x, y) on the display for the text.
 */
void frame_draw_text(const char *text, DRAWING_Position position)
{
	unsigned char start_page = (position.y/OLED_PAGE_SIZE);
	unsigned char end_page = ((position.y + FONT_HEIGHT)/OLED_PAGE_SIZE);

    for (unsigned char page=start_page; page <= end_page; page++)
    {
		unsigned char current_character = 0;
			
        while (*(text + current_character) != '\0')
        {
            unsigned char *font = font_getchararray(*(text + current_character));
			unsigned char y_position = (position.y%OLED_PAGE_SIZE);
			
            for (unsigned char x=0; x < FONT_WIDTH; x++)
            {
				unsigned char font_row = *(font + x);
				unsigned char frame_row = (position.x + current_character * FONT_WIDTH + x);
				
				unsigned char temp = 
					#ifdef FRAME_SPECIFIC_BACKGROUND
						pgm_read_byte(&frame_background[page][frame_row]);
					#else
						0x00;
					#endif
				
                if(page == start_page)
                {
					temp |= (font_row<<y_position);
                }
                else
                {
					temp |= (font_row>>(OLED_PAGE_SIZE - 1 - y_position));
                }
				
				oled_column(temp, frame_row, page);
            }
            current_character++;
        }
    }
}

/**
 * @brief Renders a formatted number on the OLED display at a specified position.
 *
 * This function receives a pointer to a number as any supported type (unsigned, signed, float, or double), converts it to a string representation according to the specified number type and radix (base), and draws the result as text at the given display position. The output can be padded with leading spaces (decimal) or zeros (other bases) to fit the desired field length. Supports decimal, hexadecimal, and other numeric bases, as well as fixed precision for floating-point numbers if `FRAME_NUMBER_ENABLE_FLOATING_POINT` is defined. Internally utilizes font rendering to display the formatted string.
 *
 * @param number Pointer to the value to display (type selected via the @p type argument).
 * @param length Minimum output width in characters (for padding).
 * @param type The type of the number (unsigned/signed int/long, or float/double if enabled).
 * @param radix Number base for formatting (e.g., decimal, hexadecimal).
 * @param position Display coordinates (x, y) for the output string.
 *
 * @note Floating point support increases code size and should be enabled only when required.
 */
void frame_draw_number(const void* number, unsigned char length, NUMBER_Type type, NUMBER_Radix radix, DRAWING_Position position)
{
	char number_buffer[40];
	char *result = NULL;
	
	unsigned long unsigned_value = 0;
    long signed_value = 0;
	
	FRAME_Number_Operation operation = FRAME_Number_Operation_Unsigned;

    switch(type)
    {
        case NUMBER_Unsigned_Int:
            unsigned_value = *((unsigned int*)number);
            break;
        case NUMBER_Unsigned_Long:
            unsigned_value = *((unsigned long*)number);
            break;
        case NUMBER_Signed_Int:
            signed_value = *((int*)number);
            operation = FRAME_Number_Operation_Signed;
            break;
        case NUMBER_Signed_Long:
            signed_value = *((long*)number);
            operation = FRAME_Number_Operation_Signed;
            break;
	#ifdef FRAME_NUMBER_ENABLE_FLOATING_POINT
        case NUMBER_Float:
        case NUMBER_Double:
            operation = FRAME_Number_Operation_Decimal;
            break;
	#endif
        default:
            return;
    }

	if(operation == FRAME_Number_Operation_Signed)
	{
		result = itoa(signed_value, number_buffer, (unsigned int)radix);
	}
#ifdef FRAME_NUMBER_ENABLE_FLOATING_POINT
    else if(operation == FRAME_Number_Operation_Decimal)
    {
	    float fvalue = *((float*)number);
	    result = dtostrf(fvalue, length, FRAME_NUMBER_PRECISION, number_buffer);
    }
#endif
    else
    {
        result = utoa(unsigned_value, number_buffer, (unsigned int)radix);
    }
	
	if(result == NULL)
	{
		return;
	}
	
	size_t result_length = strlen(result);
	
	while((result_length++) < length)
	{
		if(radix == NUMBER_Decimal)
		{
			frame_draw_text(" ", position);
		}
		else
		{
			frame_draw_text("0", position);
		}
		position.x += FONT_WIDTH;
	}
	
	frame_draw_text(result, position);
}

/**
 * @brief Inline helper function to draw an unsigned integer number on the OLED display.
 * 
 * This function wraps the more general `frame_draw_number` function, providing a convenient interface specifically for unsigned integers. It forwards the number pointer, length, radix, and drawing position to the main number rendering function with the appropriate type parameter.
 * 
 * @note Declared as inline to suggest the compiler to optimize by embedding the function code 
 * at the call site, reducing function call overhead.
 * 
 * @param number The unsigned integer value to draw.
 * @param length The minimum number of characters to display (padding as needed).
 * @param radix The numeric base (e.g., decimal, hexadecimal) for number display.
 * @param position The coordinates (x, y) on the display where the number will be rendered.
 */
inline void frame_draw_number_uint(const unsigned int number, unsigned char length, NUMBER_Radix radix, DRAWING_Position position)
{
	frame_draw_number(&number, length, NUMBER_Unsigned_Int, radix, position);
}

/**
 * @brief Inline helper function to draw a signed integer number on the OLED display.
 * 
 * This function is a simple wrapper around the generic `frame_draw_number` function, specifically for signed integers. It passes the address of the given number, the desired output length, radix, and position to the main number drawing function, specifying the type as signed int.
 * 
 * @note Declared as inline to suggest compiler optimization by embedding the function code directly at the call site, minimizing function call overhead.
 * 
 * @param number The signed integer value to draw.
 * @param length The minimum number of characters to display (with padding if necessary).
 * @param radix The numeric base (e.g., decimal, hexadecimal) for displaying the number.
 * @param position The screen coordinates (x, y) where the number will be rendered.
 */
inline void frame_draw_number_int(const int number, unsigned char length, NUMBER_Radix radix, DRAWING_Position position)
{
	frame_draw_number(&number, length, NUMBER_Signed_Int, radix, position);
}

static void frame_fill_rectangle(DRAWING_Position position, DRAWING_Size size)
{
	unsigned char start_page = (position.y/OLED_PAGE_SIZE);
	unsigned char end_page = ((position.y + size.height)/OLED_PAGE_SIZE);

	for (unsigned char page=start_page; page <= end_page; page++)
	{
		unsigned char y_position = (position.y%OLED_PAGE_SIZE);
		
		for (unsigned char x=0; x < size.width; x++)
		{
			unsigned char row = 0xFF;
			
			unsigned char temp =
			#ifdef FRAME_SPECIFIC_BACKGROUND
				pgm_read_byte(&frame_background[page][position.x + x]);
			#else
				0x00;
			#endif
			
			if(page == start_page)
			{
				row = (0xFF<<y_position) | temp;
			}
			else if(page == end_page)
			{
				row = (0xFF>>(OLED_PAGE_SIZE - 1 - y_position) | temp);
			}
			
			oled_column(row, position.x + x, page);
		}
	}
}

/**
 * @brief Clears the entire display frame.
 * 
 * This function resets the OLED display content to a blank state by calling `oled_clear()`. If the compile-time macro FRAME_SPECIFIC_BACKGROUND is defined, it additionally redraws the predefined background image stored in `frame_background` to maintain the visual context. Without FRAME_SPECIFIC_BACKGROUND, the screen is simply cleared to black.
 * 
 * The function's linkage depends on the background setting:
 * - Inline when no specific background is used, suggesting compiler optimization for small size.
 * - Normal function otherwise due to potentially larger code size from background redraw.
 */
#ifndef FRAME_SPECIFIC_BACKGROUND
	inline void frame_clear(void)
#else
	void frame_clear(void)
#endif
{
	oled_clear();

    #ifdef FRAME_SPECIFIC_BACKGROUND
	    for (unsigned char y=0; y < sizeof(frame_background)/sizeof(frame_background[0]); y++)
	    {
    	    frame_background_segment(0, (FRAME_WIDTH - 1), y);
	    }
    #endif
}

static void frame_clear_area(DRAWING_Position position, DRAWING_Size size)
{
	unsigned char start_page = (position.y/OLED_PAGE_SIZE);
	unsigned char end_page = ((position.y + size.height)/OLED_PAGE_SIZE);
	
	for (unsigned char page=start_page; page <= end_page; page++)
	{
		#ifdef FRAME_SPECIFIC_BACKGROUND
			frame_background_segment(position.x, position.x + size.width, page);
		#else
			oled_clear_page_segment(position.x, position.x + size.width, page);
		#endif
	}
}

/**
 * @brief Draws a horizontal progress bar on the OLED display.
 * 
 * This function renders a progress bar at the specified position with the given size, visually representing the completion percentage as a filled section of the bar. The filled area of the bar corresponds to the percentage value (0-100%), calculated as a width increment. The unfilled remainder of the bar is cleared to maintain visual clarity.
 * 
 * @param position The starting coordinates (x, y) of the progress bar on the display.
 * @param size The width and height dimensions of the progress bar.
 * @param percent The completion percentage to display (0 to 100).
 * 
 * @note If the percentage exceeds 100, the bar is considered fully filled. The function internally handles clearing and filling the appropriate regions.
 */
void frame_draw_bar(DRAWING_Position position, DRAWING_Size size, unsigned char percent)
{
	unsigned char increment = (size.width * percent) / 100UL;
	
	if(percent >= 100UL)
	{
		increment = size.width;
	}
	
	position.x += increment;
	size.width -= increment;
	frame_clear_area(position, size);
	
	position.x -= increment;
	size.width = increment;
	frame_fill_rectangle(position, size);
}